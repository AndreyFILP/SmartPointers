1) Взяв за основу класс SmartPtr, выполнить следующие задания. Добавить перегрузку операторов преобразования типа "operator T*()", "operator void*()", а также метод "T* Get() const", аналогичный методу стандартных интеллектуальных указателей. Определить операции сравнения ==, !=, <, >, <=, >=, аналогичные операциям сравнения обычных указателей, например, в виде
template <class T1, class T2>
bool operator==(const SmartPtr<T1>& Left, const SmartPtr<T2>& Right)
Проверить работу новых методов и операторов на примерах.

2) Реализовать вариант класса SmartPtr со стратегией владения объектом на основе связывания ссылок (см. Андрееску, раздел 7.5.4). В рамках этой стратегии не производится подсчет интеллектуальных указателей, а все объекты SmartPtr, ссылающихся на один и тот же объект, заносятся в линейный двусвязный список. Когда список становится пустым, память освобождается. Для подсчета ссылок можно, например, добавить в класс поля SmartPtr* next, SmartPtr* prev. Добавьте метод use_count(), возвращающий количество указателей в списке. Протестируйте работу измененного класса.
